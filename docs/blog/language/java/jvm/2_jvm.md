# 垃圾回收


## 三个问题
1. 什么场景下使用什么垃圾回收策略
    - 对内存要求苛刻的场景：想办法提高对象的回收效率，多回收掉一些对象，腾出更多的空间
    - CPU使用率高的情况下：降低高并发时垃圾回收的频率，让CPU更多的去执行你的业务而不是垃圾回收
2. 垃圾回收主要发生在哪些区域
    - 线程隔离区域，随着线程的创建而创建，随着线程的消亡而消亡
    - 堆和方法区是需要考虑垃圾回收的区域，而堆是垃圾回收的主要区域，主要回收的是我们创建的对象。而方法区则回收废弃的常量和不需要使用的类
3. 对象在什么时候能被回收呢？主要有两种算法
    1. 引用计数法： 通过对象的引用计数器来判断对象是否被引用了。
        - 只要有一个对象引用了对象A，A的引用计数器就会加1，同理当引用失效的时候，A的引用计数器就会减1。如果A的引用计数器的值变为0的话，就说明没有对象引用了
        - 引用计数法简单高效，但是无法解决循环引用的情况，所以java不选择该算法
    2. 可达性分析：以根对象（GC Roots）作为起点向下搜索，走过的路径被称为引用链（Reference Chain），如果某个对象到根对象没有引用链时，就认为这个对象是不可达的，可以回收
        - 那么哪些对象可以作为根对象呢？
        1. 虚拟机栈（栈帧中的本地变量表）中引用的对象 -> 一般是一些局部变量
        2. 方法区中类静态属性引用的对象
        3. 方法区中常量引用的对象
        4. 本地方法栈中JNI（即native方法）引用的对象
        - 什么是引用呢？
        1. 强引用 new出来的对象引用，只要强引用存在，永远不会回收被引用的对象，哪怕是内存溢出
        2. 软引用 `SoftReference<String>` 用来描述有用，但不是必须的对象。软引用关联的对象只有在内存不足的时候才会被回收。比价时候做缓存，如网页缓存、图片缓存等
        3. 弱引用 `WeakReference<String>` 也是用来描述非必需对象的，当JVM垃圾回收的时候，不管内存是否充足都会回收被弱引用关联的对象
        4. 虚引用 `ReferenceQueue<String>` 不影响对象的生命周期，如果一个对象只有虚引用，就相当于没有引用一样，在任何时候都有可能被垃圾回收，主要用于跟踪对象被垃圾回收器回收的活动，需配合引用队列使用
        - 可达性算法注意点
        1. 一个对象不可达，也不一定会被回收，只是死缓
        2. 想要真正处死一个对象的流程大致是这样的
            1. 符合对象没有引用链和GC Roots链接
            2. 有无必要执行finalize()
            3. 有必要的话，将对象放入F-Queue队列中，使用一个低优先级的线程来执行对象的finalize方法
            4. 如果在调用对象的finalize方法中，对象与其他对象重新建立连接，或者对象自救，则会将该对象从F-Queue队列中移除
            5. 否则的话，则会回收该对象

## 垃圾回收算法
1. 标记 - 清除：
    1. 标记需要回收的对象 
    2. 清理掉需要回收的对象
    3. 缺点：
        1. 遍历空闲链表需要消耗时间，极端情况下需要遍历完全部链表才能确定对象该分配到哪里去，或者无法分配
        2. 效率不高，标记和清除的效率都不高
        2. 标记清除后产生大量不连续的内存碎片，从而导致在分配大对象时触发GC
2. 复制：
    1. 把内存分为两块，每次只使用其中的一块
    2. 将正在使用中的内存中的存活对象，复制到未使用的内存中去，然后清除掉正在使用的的内存中的所有对象
    3. 交换两个内存的角色，等待下一次被回收
    4. hotSpot默认Eden和Survivor比是8:1，也就是每次能使用90%的新生代空间
    5. 如果Survivor空间不够，就要依赖老年代进行分配担保，把放不下的对象直接进入老年代。什么是分配担保？
        -  新生代空间放置不下：1. 对象很多，Eden+某一块Survivor区的对象空间 > Eden+另一块Survivor区的空间。 2. 新对象很大，大于新生代剩余空间
        -  Minor GC前，JVM会检查老年代的最大可用的连续空间，是否大于新生代所有对象的总空间，如果大于，可以确保Minor GC是安全的
        -  如果小于，JVM会首先检查是否设置了允许担保失败，如果允许，则检查老年代最大可用连续空间，是否大于历次晋升到老年代对象的平均大小
        -  如果老年代可以空间大于历次晋升到老年代对象的平均大小，尝试一次MinorGC
        -  否则执行fullGC
    5. 缺点：
        1. 内存利用率低
3. 标记 - 整理：
    1. 标记需要回收的对象
    2. 把存活的对象压缩到内存的一端
    3. 清除掉边界外的所有空间
    4. 缺点：
        1. 整理存在开销
4. 分代收集算法
    - 新生代回收（Minor GC ｜ Young GC） 
        - 触发条件：Eden空间不足
    - 老年代回收 (Major GC)，Major GC 时常会伴随着 Minor GC，所以 Major GC 约等于 Full GC
    - 清理整个堆（Full GC）
        - 触发条件：
            1. 老年代空间不足：空间真的不足 和 内存碎片导致没有连续的内存
            2. 元空间不足
            3. 要晋升老年代的对象所占用的空间大于老年代剩余空间
            4. 显式的调用的System.gc()
                - 建议垃圾回收器执行垃圾回收
                - -XX:+DisableExplicitGC 参数，忽略 System.gc() 调用
    - 注意：
        - 新建的对象不一定分配到伊甸园 ： 1. 大于 -XX:PretenureSizeThrehold 阈值。 2. 新生代空间不够
        - 对象不一定达到年龄才进入老年代 ：动态年龄：如果Survivor区里面，所有相同年龄的对象的大小总和大于Survivor空间的一半，那么年龄大于这个年龄的对象会直接进入老年代
    - 调优原则：
        - 合理设置Survivor区大小，避免内存浪费
        - 让GC尽可能发生在新生代，避免FullGC
5. 增量算法
    - 每次只收集一小片内存的垃圾，减少系统的停顿 

## 垃圾回收器
- 垃圾回收算法为垃圾回收提供理论支持
- 垃圾回收器利用垃圾回收算法，实现垃圾回收的实践落地
1. 术语：
    1. Stop The World：
        - 简写为STW，也叫全局停顿。Java代码停止运行，Native代码继续运行，但是不能与JVM交互
        - 原因：多半由于垃圾回收导致；也可能是Dump线程、死锁检查或Dump堆等
        - 危害：服务停止、没有响应；主从切换，危害生产环境
    2. 并行收集和并发收集：
        - 并行收集：指多个垃圾收集线程并行工作，但是收集工程中用户线程（业务线程） 还是处于等待状态的
        - 并发收集：指用户线程和垃圾收集线程同时工作
    3. 吞吐量：
        - CPU用于运行用户代码的时间与CPU总消耗时间的比值
        - 运行用户代码的时间/（运行用户代码的时间 + 垃圾回收的时间）
    4. 安全点：
        - 当线程运行到这个位置的时候，线程的一些状态是可以被确定的
        - 这些特定的位置主要有：
            1. 循环的末尾 
            2. 方法临返回前 / 调用方法的call指令后 
            3. 可能抛异常的位置 
2. Serial
    - 单线程
    - 简单高效，无线程交互的开销
    - 收集过程用户线程全程STW
    - 适用于客户端程序，如：java -client -jar XXX 和 单核机器
3. ParNew
    - Serial的多线程版本
    - JVM参数、STW表现和垃圾收集算法 同Serial
    - 多线程，可使用 -XX:ParallelGCThreads设置垃圾收集线程数，一般使用CPU核心数
4. Parallel Scavenge
    - 吞吐量优先收集器
    - 采用的也是复制算法
    - 也是并行的多线程收集器，这一点和 ParNew 类似
    - 可以达到一个可控制的吞吐量
        - -XX:MaxGCPauseMillis: 控制最大的垃圾收集停顿时间（尽力）
        - -XX:GCTimeRatio: 设置吞吐量的大小，取值0-100，系统花费不超过1/(1+n)的时间用于垃圾收集
        - -XX:+UseAdptiveSizePolicy 打开自适应GC策略：打开后无需手动设置新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurviviorRatio）等参数。虚拟机会自动根据系统运行的情况收集性能监控信息，动态地调整这些参数，从而达到最优的的停顿时间以及最高的吞吐量
    - 适用于注重吞吐量的场景
5.  Serial Old
    - Serial收集器的老年代版本
    - 标记-整理算法
    - 可以和Serial/ParNew/Parallel Scavenge 这三个新生代的垃圾收集器配合使用
    - CMS收集器出现故障，也会使用 Serial Old 作为后备
6. Parallel Old
    - Parallel Scavenge收集器老年代版本
    - 标记-整理算法
    - 只能和Parallel Scavenge配合使用
    - 适用于关注吞吐量的场景
7. CMS
    - 全称：Concurrent Mark Sweep
    - 并发收集器
    - 标记-清除算法 
    - 步骤：
        1. 初始标记（initial mark）：
            - 标记根对象能直接关联到的对象 
            - STW
        2. 并发标记（concurrent mark）：
            - 找到所有GC Roots能够关联到的对象，耗时稍长
            - 并发执行，无STW
        3. 并发预清理（concurrent-perclean）：
            - 重新标记那些在并发标记阶段，引用被更新的对象，从而减少后面重新标记的工作量
            - 并发执行，无STW
            - 可使用 -XX:-CMSPercleaningEable关闭并发预清理阶段，默认打开
        4. 并发可终止预清理（concurrent-abortable-perclean）：
            - 和 并发预清理 做的事情一样，并发执行，无STW
            - 当Eden的使用量大于CMSScheduleRemarkEdenSizeThrehold的阈值（默认2M）时，才会打开
            - 主要作用：允许我们能够控制预清理阶段的结束时机。比如扫描多长时间（CMSMaxAbortablePrecleanTime,默认5s）,或者Eden区使用占比达到一定阈值（CMSScheduleRemarkEdenPenetration,默认50%）就结束本阶段
        5. 重新标记（remark）
            - 修正并发期间，因为用户程序继续执行，导致标记发生变动的那些对象的标记
            - 一般来说，重新标记话费的时间要比初试标记阶段长一些，比并发标记的时间短一些
            - 存在STW
        6. 并发清除（concurrent sweep）：**标记-清除 算法**
            - 基于标记结果，清除掉前面标记出来的垃圾
            - 并发执行，无STW
            - 为何不“并发-整理”呢？ 因为是并发执行，如果整理对象的话需要移动对象的位置，很难保证程序不出问题
        7. 并发重置（concurrent reset）
            - 清理本次CMS的上下文信息，为下一次GC作准备
    - 优点：
        - STW时间短
        - 大多数过程都是并发执行
    - 缺点：
        - CPU资源比较敏感 - 并发阶段可能导致应用吞吐量降低
        - 无法处理浮动垃圾
        - 不能等到老年代几乎满了才开始收集，需预留一部分内存。
            - 预留内存不够 -> Concurrent Mode Failure -> Serial Old作为后备
            - 使用CMSInitiatingOccupancyFraction设置老年代占比达到多少就触发垃圾收集，默认68%
        - 内存碎片，基于标记-清除算法
            - UseCMSCompactAtFullCollection:在full GC后是否要进行内存碎片整理，默认开启
            - CMSFUllGCsBeforeCompaction：在进行几次full GC后就进行一次内存碎片的整理，默认为0
    - 适用于希望系统停顿时间短，响应速度快的场景，比如各种服务器应用程序
8. G1
    - Garbge First
    - 面向服务器端应用的垃圾收集器
    - G1把Java堆划分成了若干个大小相等的区域，每一个区域叫做region
    - region的大小可以通过 -XX:G1HeapRegionSize 来指定，取值范围是1～32MB，且必须为2的整数幂
    - 同一个代里面的对象可能是不连续的
    - Humongous 是用来存储大对象的，某个对象的大小超过了region的一半就认为是大对象。如果一个对象大于一个region的大小，那么会存放在多个连续的region当中。事实上，G1会把Humongous也看作是老年代的一部分
    - 设计思想
        - 内存分块（Region）
        - 跟踪每一个Region中垃圾堆积的价值大小
        - 构建一个优先列表，根据允许的收集时间，优先回收价值高的region
    - 垃圾收集机制
        - Young GC ：
            - 所有的Eden region满了之后，就会触发YoungGC
            - Eden region的对象都会转移到Survivor Region里面去
            - 原先Survivor Region中的对象会转移到其他的Survivor Region中，或者晋升到Old Region
            - 空闲的Region会被放入空闲列表中，等待下一次被使用
        - Mixed GC
            - 老年代大小占整个堆的百分比达到一定阈值的时候，会触发Mixed GC。可使用 -XX:InitiatingHeapOccupancyPercent 指定，默认45%
            - Mixed GC会回收所有的Young Region和 **部分**（根据回收的时间和垃圾堆积的价值来选择的） Old Region
            - 执行过程：
                1. 初始标记（initial mark）：
                    * 标记根对象能直接关联到的对象 
                    * STW
                2. 并发标记（concurrent mark）：
                    * 找到所有GC Roots能够关联到的对象，耗时稍长
                    * 并发执行，无STW
                3. 最终标记（final mark）
                    * 修正并发期间，因为用户程序继续执行，导致标记发生变动的那些对象的标记
                    * 存在STW
                4. 筛选回收（Live Data Counting and Evacuation）:
                    * 对各个Region的回收价值和成本进行排序
                    * 根据用户所期望的停顿时间（MaxGCPauseMillis）来指定回收计划，并选择一些Region进行回收
                    * 回收过程：**复制 算法**
                        1. 选择一系列Region构成一个回收集set
                        2. 把决定回收的Region中存活的对象复制到空的Region中
                        3. 删除掉需回收的Region -> 无内存碎片
                        4. 筛选阶段存在STW
            - 除了并发标记，其他都存在STW，但是由于只清理堆的部分区域，所以STW的时长是可控的
        - Full GC
            - 复制对象内存不够，或者无法分配足够内存（比如大对象没有连续的Region分配）时，就会触发FullGC
            - 触发FullGC，使用的是Serial Old模式，会长时间STW
    - G1优化原则，尽可能减少FullGC的发生，优化思路：
        1. 增大预留内存（增大-XX:G1ReservePercent,默认为堆的10%）
        2. 更早的回收垃圾（减少 -XX:InitiatingHeapOccupancyPercent，默认45%，老年代达到该值就触发Mixed GC）
        3. 增加并发阶段使用的线程数（增大 -XX:ConcGCThreads），会影响吞吐量
    - 特点：
        1. 作用在整个堆 
        2. 可控的停顿时间  MaxGCPauseMillis=200
        3. 无内存碎片
    - 适用场景：
        1. 占用内存较大的应用（6G以上）
        2. 替换CMS收集器


>Serial：采用复制算法</br>
>Parallel New（并行）：采用复制算法</br>
>Parallel Scavenge（并行）：采用复制算法</br>
>Serial Old（串行）：采用标记-整理算法</br>
>Parallel Old（并行）：采用标记-整理算法</br>
>CMS：采用标记-清除算法</br>
>G1：采用复制算法



<comment/>